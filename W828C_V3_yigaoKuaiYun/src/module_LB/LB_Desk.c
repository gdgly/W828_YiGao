#include "LB_Desk.h"
#include "hyhwCif.h"
#include "hyhwGPIO.h"
#include "hyhwCkc.h"
#include "hyhwDma.h" 
#include "grap_api.h"
#include "base.h"
#include "jpeg_api.h"
#include "AbstractFileSystem.h"
#include "hyhwIntCtrl.h"
#include "Common_Dlg.h"
#include "Common_Widget.h"

#define CODE_MAX_LEN 500

/*解析后条形码的数据内容*/
U8  gu8BarCode[CODE_MAX_LEN];
U32 gu32BarLen;

eLBSTATE eLBState;

//U8	*gpLBcodeBuf;
U8  gu8LBRead,gu8LBWrite;
U8  gu8LBPrevDelayFrame;//预览丢弃帧数
U32 gu32LBQuitTime;//无操作时超时退出

U8	*gpLBUseBuf;//外部提供    最少2.1M
U32 gu32LBcodeLen;

/*经过缩放后的存储位置*/
U8 *gpLBQvga_y,*gpLBQvga_u,*gpLBQvga_v;
/*应用进程显示使用*/
U8 *gpLBDisplayRgb;
U8 *gpLBDecodeRgb;
/*用作预览的buf*/
U8 *gpLBPrev_y[LB_PREVIEW_BUF_NUM],*gpLBPrev_u[LB_PREVIEW_BUF_NUM],*gpLBPrev_v[LB_PREVIEW_BUF_NUM];



//0:成功   -1:失败
int LB_SendData(tGRAPDESKBOX *pDesk, U8 *pCode);

//外框  92x71  未对焦颜色为黑色  对焦后颜色为0X4c0
const U8 LB_Focus1[]=
{
	0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xF0,0xFF,0xFF,0x80,0x00,
	0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xF0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x30,0xDF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xB0,
	0xDF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xB0,0xD8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,
	0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,
	0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,
	0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,
	0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,
	0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,
	0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xD8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xB0,0xDF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,
	0x00,0x1F,0xFF,0xB0,0xDF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xB0,
	0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0xFF,0xFF,0x80,0x00,
	0x00,0x00,0x00,0x00,0x00,0x1F,0xFF,0xF0,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,
	0x00,0x1F,0xFF,0xF0
};

//内框   88x67  未对焦颜色为0X679   对焦颜色为0X7e6
const U8 LB_Focus2[]=
{
	0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0x80,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
	0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,
	0xFF
};


/*=========================================================================================*/
/*********************************************************************
* 函数名  : LB_SensorISR
* 功能    : camera中断处理函数
* 输入    : none 
* 输出    : none
* 返回    :
**********************************************************************/
void LB_SensorISR()
{
	U8 rd,wr,wr2;

	rd = gu8LBRead;
	wr = gu8LBWrite;

	/* clear frame flag*/
	hyhwmCif_clearFrameFlag();
	wr2 = wr + 1;
	if(wr2 >= LB_PREVIEW_BUF_NUM)
	{
		wr2 -= LB_PREVIEW_BUF_NUM;
	}
	if(wr2 != rd)
	{
		wr = wr2;
	}
	/*if interrption coming，store the corresponding data to preview_y/u/v buffers*/
	hyhwCif_frameStart(	(U32)gpLBPrev_y[wr],(U32)gpLBPrev_u[wr],(U32)gpLBPrev_v[wr] );
	gu8LBWrite = wr;

	return;
}


static void LB_StopInterrupt()
{
	hyhwmCif_disable();
	hyhwInt_disable(INT_BIT_CAMERA);
	hyhwInt_clear(INT_BIT_CAMERA);
	hyhwmCif_intDisable();
	hyhwmCif_clearFrameFlag();
}

static int LB_HwDeInit()
{
	hyhwLcd_flashDisable();//关闭闪光灯
	
	hyhwmCif_disable();
	hyhwmCif_intDisable();
	hyhwInt_disable(INT_BIT_CAMERA);
	hyhwInt_ConfigCamera_ISR(NULL);
	hyhwmCif_clearFrameFlag();
	hyhwInt_clear(INT_BIT_CAMERA);
	hyhwInt_ConfigCodecISR(NULL);

	hyhwCmosSensor_standby_enable();

	/*关闭硬件解码设备*/
	hyhwJpegG2d_Ctrl(0);
	hyhwCmosSensor_powerCtrl(EnableOff);
}

static int LB_DeInit()
{
	LB_HwDeInit();

	eLBState = LB_STATE_QUIT;
	
	return 0;
}

static int LB_ParaInit()
{
	eLBState	= LB_STATE_INIT;
	gu8LBRead	= 0;
	gu8LBWrite	= 0;
	gu32LBcodeLen = 0;
	
	gu8LBPrevDelayFrame	= 5;
	
	gu32LBQuitTime = rawtime(NULL);
	
	return 0;
}

static int LB_Alloc()
{
	U8  i;
	
	/*四字节对齐*/
    gpLBUseBuf = (char *)((unsigned)(gpLBUseBuf + 3) & 0xFFFFFFFC);
    
    //缩放后的数据buf   115200
    gpLBQvga_y	= gpLBUseBuf;
	gpLBUseBuf	+= LB_PREVIEW_320_240_PIXELS;
	gpLBQvga_u	= gpLBUseBuf;
	gpLBUseBuf	+= (LB_PREVIEW_320_240_PIXELS>>2);
	gpLBQvga_v	= gpLBUseBuf;
	gpLBUseBuf	+= (LB_PREVIEW_320_240_PIXELS>>2);
	
	//用来存放显示到屏上的RGB数据  153600
	gpLBDisplayRgb	= gpLBUseBuf;
	gpLBUseBuf	+= (LB_PREVIEW_320_240_PIXELS<<1);
	
	gpLBDecodeRgb	= gpLBUseBuf;
	gpLBUseBuf	+= (LB_PREVIEW_640_480_PIXELS<<1);
	
	/*用作预览的buf   1843200*/
	for(i = 0; i < LB_PREVIEW_BUF_NUM; i++)
	{
		gpLBPrev_y[i] = gpLBUseBuf;
		gpLBUseBuf   += LB_PREVIEW_Y_SIZE;
		gpLBPrev_u[i] = gpLBUseBuf;
		gpLBUseBuf   += LB_PREVIEW_U_SIZE;
		gpLBPrev_v[i] = gpLBUseBuf;
		gpLBUseBuf   += LB_PREVIEW_V_SIZE;
	}
		
	return 0;
}

static int LB_HwInit()
{
	hyhwCmosSensor_powerCtrl(EnableOn);
	//打开硬件解码设备JPEG & 2D
	hyhwJpegG2d_Ctrl(1);
	//打开camera时钟
	hyhwCpm_busClkEnable(CKC_CAM);
	//设置camera的中断处理函数
	hyhwInt_ConfigCamera_ISR(LB_SensorISR);
	
	if(hyhwCmosSensor_Init() != 0)
	{
		return -1 ;
	}
	hyhwCif_init();
	//sleep(200);
	hyhwmCif_clearIntFlag();

#ifdef LB_VGA_PREVIEW	
	//设置预览模式
	hyhwCif_setVGAMode();   //640 x 480
	//hyhwCif_setSXGAMode(1);
#elif defined LB_QVGA_PREVIEW
	hyhwCif_setQVGAMode();
#endif
	hyhwmCif_clearFrameFlag();
	
	//指定INT_BIT_CAMERA中断为IRQ中断,并使能
	hyhwInt_setIRQ(INT_BIT_CAMERA);
	hyhwInt_enable(INT_BIT_CAMERA);

	/*获取一帧数据*/
	hyhwCif_frameStart((U32)gpLBPrev_y[0],(U32)gpLBPrev_u[0],(U32)gpLBPrev_v[0]);

	hyhwLcd_flashDisable();//关闭闪光灯
	
	return 0;
}


static int LB_Init()
{
	
	LB_ParaInit();
	LB_Alloc();
	if(-1 == LB_HwInit())
	{
		return -1 ;
	}
	
	return 0;
}


/*=========================================================================================*/
const tGrapViewAttr LBViewAttr[]=
{
	{COMM_DESKBOX_ID, 0,0,240,320,0,0,0,0,TY_UNITY_BG1_EN,TY_UNITY_BG1_EN,0,0,1,0,0,0},//背景
	
	{BUTTON_ID_1,  83,282,73,34,  83,282,156,316,   YD_AN1_EN,	YD_AN2_EN,	0,0,1,0,0,0},//拍照
};

const tGrapButtonPriv LBBtnPrv[]=
{
	{(U8 *)"返回", 0xffff,0x0,FONTSIZE8X16,0,2,KEYEVENT_ESC,0,  NULL},//
};


#define LINE_LEN	(25)
void LBdrawPreviewFrame(U16 *pdata, U16 kBMPHigh, U16 kBMPWidth, U16 kRow, U16 kColumn, U16 Fcolor)
{
	int i, j;
	U16 *pOffset;
	
	//左上横线
	for (i=0; i<LINE_LEN; i++)
	{
		pOffset = (U16 *)((U8*)pdata+(kRow*240+kColumn+i)*2);
		*pOffset = Fcolor;
	}
	//右上横线
	for (i=0; i<LINE_LEN; i++)
	{
		pOffset = (U16 *)((U8*)pdata+(kRow*240+(kColumn+kBMPWidth-LINE_LEN)+i)*2);
		*pOffset = Fcolor;
	}
	//左下横线
	for (i=0; i<LINE_LEN; i++)
	{
		pOffset = (U16 *)((U8*)pdata+((kRow+kBMPHigh)*240+kColumn+i)*2);
		*pOffset = Fcolor;
	}
	//右下横线
	for (i=0; i<LINE_LEN; i++)
	{
		pOffset = (U16 *)((U8*)pdata+((kRow+kBMPHigh)*240+(kColumn+kBMPWidth-LINE_LEN)+i)*2);
		*pOffset = Fcolor;
	}
	
	//左上竖线
	for (i=0; i<LINE_LEN; i++)
	{
		pOffset = (U16 *)((U8*)pdata+((kRow+i)*240+kColumn)*2);
		*pOffset = Fcolor;
	}
	//右上竖线
	for (i=0; i<LINE_LEN; i++)
	{
		pOffset = (U16 *)((U8*)pdata+((kRow+i)*240+kColumn+kBMPWidth)*2);
		*pOffset = Fcolor;
	}
	//左下竖线
	for (i=0; i<LINE_LEN; i++)
	{
		pOffset = (U16 *)((U8*)pdata+((kRow+kBMPHigh-LINE_LEN+i)*240+kColumn)*2);
		*pOffset = Fcolor;
	}
	//右上竖线
	for (i=0; i<LINE_LEN; i++)
	{
		pOffset = (U16 *)((U8*)pdata+((kRow+kBMPHigh-LINE_LEN+i)*240+kColumn+kBMPWidth)*2);
		*pOffset = Fcolor;
	}
}

void LB_Frame(U16 *ShowBuffer, U16 fcolor1, U16 fcolor2, U8 flag)
{
	U16  *p1,*p2;
	U32 len;
	U16 leftS;
	U16 i,j,alpha;
	U16 r,g,b, t,t1,t2;
	
	if(flag == 1)
	{
		LBdrawPreviewFrame(ShowBuffer,120,120,90,60,0x0E70);
	}
}


//加载预览数据
void LB_LoadDcData(U16 kRow, U16 kCol, U16 kHigh, U16 kWidth, U8 *pBuf)
{
	U8  *pMemory,*pTemp,*pRgb;
	U16 *pD,*pS;
	U32 off,size;
	int i,j;
	
	pMemory = (U8 *)Get_Display_DisplayMemory_Offset();

#ifdef W818C
	off  = (kRow*gLcd_Total_Column+kCol)*2;//在显存中的偏移
	pD   = (U16 *)(pMemory+off);
	pS = (U16 *)pBuf ;
	
	for(i = 0 ; i < kWidth; i++)
	{
		for(j = 0 ; j < kHigh ; j++)
		{
			pD[j] = pS[kWidth * (kHigh-1-j) + i] ;
		}
		pD += gLcd_Total_Column;
	}
#else
	size = kHigh*kWidth;
	off  = (kRow*gLcd_Total_Column+kCol)*2;//在显存中的偏移
	pD   = (U16 *)(pMemory+off);
	memcpy((char *)pD,pBuf,size*2);
#endif	
	
	QR_Frame((U16 *)pMemory,0x0, 0x679, 1);
	
	drvLcd_BMPFromDisplayMemory2Screen();
	return ;
}

int LB_decode(U16 *pData, U16 width, U16 height, char *pOut)
{
	int ret = 0;
	int i,j,size;
	int color,r,g,b;
	U8  *pdst, *pBuf;	
	
	//Epass_InitToSdram_buf();
	
	pdst = (U8 *)gpLBDecodeRgb;
	size = height*width;

	for(i = 0, j = 0; i < size; i++)
	{
		r = ((pData[i]>>11)<<3);
		g = ((pData[i]>>5)&0x3F)<<2;
		b = ((pData[i]&0x1F)<<3);
		
	//	r |= 0x07;
	//	g |= 0x03;
	//	b |= 0x07;
		
		/**pBuf++;
		r = *pBuf++;
		g = *pBuf++;
		b = *pBuf++;*/
		
		color = r+g+b;
		pdst[j++] = color/3;
	}

	pdst[j] = 0;
	
//tick = rawtime(NULL);
	//ret = TDecodeStr(pdst,width,height, pOut);
	ret = DecodeStrOut(pdst, width, height, pOut);
	
	//if(ret == 1)
	//	hyUsbPrintf("used time = %d   %d   %s \r\n",ABS(rawtime(NULL)-tick),width, pOut);

	return ret;
}

int LB_Preview()
{
	U8	rd,wr;
	U8	intLev;
	U8	*pTemp;
	int tLBret, frames;
	
	rd = gu8LBRead;
	wr = gu8LBWrite;
	
	if(rd != wr)
	{
		if(gu8LBPrevDelayFrame > 0)
		{
			gu8LBPrevDelayFrame--;
		}
		else// if(hyhwLcd_RGBDmaOK() == TRUE)
		{
		#ifdef LB_VGA_PREVIEW	
			/*预览图像缩放成可以显示的图像*/
			Comm_HWScaler_YUV420_t((U32*)gpLBPrev_y[rd],(U32*)gpLBPrev_u[rd],(U32*)gpLBPrev_v[rd],
						 (U32*)gpLBQvga_y,(U32*)gpLBQvga_u,(U32*)gpLBQvga_v,
						 (LB_PREVIEW_H_SIZE<<16)|LB_PREVIEW_W_SIZE,(LB_PREVIEW_DISPLAY_HEIGHT<<16)|LB_PREVIEW_DISPLAY_WIDTH );
			
			/*YUV-->RGB, gpLBDisplayRgb 320 x 240 x 2*/
			Color_YUV420toRGB565_Buf_t((U32*)gpLBQvga_y,(U32*)gpLBQvga_u,(U32*)gpLBQvga_v,
    		                         (U32*)gpLBDisplayRgb,
    		                         (LB_PREVIEW_DISPLAY_HEIGHT<<16)|LB_PREVIEW_DISPLAY_WIDTH,0,
    		                         (LB_PREVIEW_DISPLAY_HEIGHT<<16)|LB_PREVIEW_DISPLAY_WIDTH,
    		                         (LB_PREVIEW_DISPLAY_HEIGHT<<16)|LB_PREVIEW_DISPLAY_WIDTH,0);
		#elif defined LB_QVGA_PREVIEW
			/*YUV-->RGB, gpLBDisplayRgb 320 x 240 x 2*/
			Color_YUV420toRGB565_Buf((U32*)gpLBPrev_y[rd],(U32*)gpLBPrev_u[rd],(U32*)gpLBPrev_v[rd],
    		                         (U32*)gpLBDisplayRgb,
    		                         (LB_PREVIEW_DISPLAY_HEIGHT<<16)|LB_PREVIEW_DISPLAY_WIDTH,0,
    		                         (LB_PREVIEW_DISPLAY_HEIGHT<<16)|LB_PREVIEW_DISPLAY_WIDTH,
    		                         (LB_PREVIEW_DISPLAY_HEIGHT<<16)|LB_PREVIEW_DISPLAY_WIDTH,0);
		#endif

        	LB_LoadDcData(LB_DISPLAY_START_ROW,LB_DISPLAY_START_COL,LB_PREVIEW_DISPLAY_HEIGHT,LB_PREVIEW_DISPLAY_WIDTH,gpLBDisplayRgb);

    		if(eLBState == LB_STATE_START)
    		{
    			eLBState = LB_STATE_INIT;
				
				if(1 == LB_decode(gpLBDisplayRgb, LB_PREVIEW_DISPLAY_WIDTH, LB_PREVIEW_DISPLAY_HEIGHT, gu8BarCode))
    			{
    				eLBState = LB_STATE_GETOK;
    			}
        	}
        	
        	rd++;
			if(rd >= LB_PREVIEW_BUF_NUM)
			{
				rd -= LB_PREVIEW_BUF_NUM;
			}
			gu8LBRead = rd;
		}
	}
	
	if(gu8LBPrevDelayFrame > 0)
	{
		eLBState = LB_STATE_INIT;
		return 0;
	}
	
	/*带闪光灯，自动打开闪光灯*/
	if(eLBState == LB_STATE_INIT)
	{
		//hyhwLcd_flashEnable();
	}
	
	return 0;
}


int LB_DeskboxHandle(void *pView, GRAP_EVENT *pEvent)
{
	tGRAPDESKBOX	*pDesk;
	U32				delay;
	U32				message, wParam, lParam;
	int				ret = -1;
	tGRAPVIEW		*pSubView;
	tGRAPZORDER		*pSubZorder ;
	static U32 LBdelay=0;
	
	pDesk	= (tGRAPDESKBOX *)pView;
	message = pEvent->message;
	wParam  = pEvent->wParam;
	lParam  = pEvent->lParam;
	
	switch(message)
	{
	case VIEW_DRAW:		  
		pDesk->draw(pDesk, 0, 0); 
		if( (TRUE == *pDesk->pUIFocus) && !(*pDesk->pQuitCnt))
		{
			DisplayData2Screen();
		}
		return SUCCESS;
	    break;
	case VIEW_QUIT:
	case VIEW_ESC:
		*pDesk->pQuitCnt = 1;
		break;
	case VIEW_QUITALL:
		*pDesk->pQuitCnt = 0xff;
		break;
	case VIEW_PRESS:
		break;
	case VIEW_REV_PULLMSG:
	    if (pDesk->pPullChild == NULL)
        {//第一点    
                        
            if (VIEW_PULL_END == pEvent->extParam) return SUCCESS;
            
            pEvent->extParam = VIEW_PULL_START;       
            
            pSubZorder = pDesk->pZorderList;

			while (pSubZorder)
			{
				pSubView = pSubZorder->pMember;
				
				if (pSubView->view_attr.enable == 1 && VIEW_PULL_START == pSubView->handle(pSubView,pEvent))
                {
                    pDesk->pPullChild = pSubView;
                    pDesk->lastPoint = lParam;
                    pDesk->pullTimeOut = rawtime(NULL);
                    break;    
                }
                
				pSubZorder = pSubZorder->pNext;
			}
        }
        else
        {//后续点
            int rv;
            
            pEvent->wParam = pDesk->lastPoint;
            
            pSubView = pDesk->pPullChild;
            rv = pSubView->handle(pSubView,pEvent);
            	        
            if (VIEW_PULL_END == rv)
            {
                pDesk->pPullChild = NULL;	        
            }
            else if (VIEW_PULL_ING == rv)
            {
                pDesk->lastPoint = lParam;
            }
            
            //特殊返回值
            if(rv == PARSED )
    		{
    	        pSubZorder = pDesk->pZorderList ;
    	        while(pSubZorder)
				{
					if(pSubView == pSubZorder->pMember)
					{
						break;
					}
					pSubZorder = pSubZorder->pNext;
				}
    			Grap_UpdateZorder(((tGRAPVIEW *)pView)->pParent, pSubZorder);	
    			pDesk->pPullChild = NULL;			
    		}
    		else if(RETURN_FOCUSMSG == rv)
    		{
    			pDesk->pPullChild = NULL;
    			return RETURN_FOCUSMSG;
    		}
    		else if(RETURN_QUIT == rv)
    		{
    			pDesk->pPullChild = NULL;
    			return RETURN_QUIT;
    		}
        }	    
        pDesk->pullTimeOut = rawtime(NULL);
	    break;
	default:
		break;
	}
	
	if(message != VIEW_QUIT && message != VIEW_ESC && message != VIEW_REV_PULLMSG && message != VIEW_KEY_MSG)
	{
		tGRAPZORDER  *pSubZorder ;
		S32		ret = 0 ;
		pSubZorder = pDesk->pZorderList ;

		while (pSubZorder)	// deskbox负责各个子控件的handle的调用。
		{
			pSubView = pSubZorder->pMember ;

			if( pSubView->view_attr.enable || message == VIEW_INIT)
			{
				ret = pSubView->handle(pSubView, pEvent);
				if(ret == PARSED )
				{
					Grap_UpdateZorder(((tGRAPVIEW *)pView)->pParent, pSubZorder);
					break ;
				}
				else if(RETURN_FOCUSMSG == ret)
				{
					return RETURN_FOCUSMSG;
				}
				else if(RETURN_QUIT == ret)
				{
					return RETURN_QUIT;
				}
			}
			pSubZorder = pSubZorder->pNext;
		}
	}
	
	if(eLBState == LB_STATE_INIT || eLBState == LB_STATE_START)
	{
		delay = ABS(rawtime(NULL) - gu32LBQuitTime);
		if(delay >= 18000)//3 min
		{//无操作 超时退出
			*pDesk->pQuitCnt = 1;
		}
		else
		{
			if(ABS(rawtime(NULL) - LBdelay) >= 70)
			{
				eLBState = LB_STATE_START;//每次都可以识别
				LBdelay = rawtime(NULL);
			}
	//hyUsbPrintf("*pDesk->pQuitCnt  == %d \r\n", *pDesk->pQuitCnt);		
			/*图像预览*/
			LB_Preview();
			if(eLBState == LB_STATE_GETOK)//识别成功
			{
				tStrDispInfo	display;
				U8				ret;
				
				/*获取条码成功*/
				Remind_Fun(0,0);
				
				LB_StopInterrupt();
				hyhwLcd_flashDisable();
				
				//在预览区的下方显示出识别的条码信息
				display.string		= gu8BarCode;
				display.color		= 0xffff;
				display.font_size	= FONTSIZE8X16;
				display.font_type	= 0;
				display.flag		= 0;
				display.keyStr = NULL;
				Grap_WriteStringMulti(8,232,224,280,&display);
				DisplayData2Screen();

				Com_SpcDlgDeskbox("识别成功!",0,pDesk,2,NULL,NULL,DLG_ALLWAYS_SHOW);
				Grap_ClearScreen(0,232,224,280);

				{
					LB_ParaInit();
					/*获取一帧数据*/
					hyhwCif_frameStart((U32)gpLBPrev_y[0],(U32)gpLBPrev_u[0],(U32)gpLBPrev_v[0]);
				
					hyhwmCif_intEnable();
					hyhwInt_enable(INT_BIT_CAMERA);
				}
				
				LBdelay = rawtime(NULL);
			}
		}
	}
	
	
	return SUCCESS;
}


S32 LB_ButtonRecvPullMsg(void *pView,GRAP_EVENT *pEvent)
{
    U32 extParam, message, wParam, lParam ;
    tGRAPBUTTON *pButton;
	tGrapViewAttr *pview_attr;
	tGrapButtonPriv  *pbtn_privattr;
	tGrapButtonBuffPic *pbtnpic;
	tGRAPVIEW *pTempView;
	S32 ret = FAIL;
	int x, y ;

	pButton = (tGRAPBUTTON *)pView;
	pview_attr = &(pButton->view_attr);
	pbtn_privattr = &(pButton->btn_privattr);
    
    message = pEvent->message ;
	wParam = pEvent->wParam ;
	lParam = pEvent->lParam ;
	extParam = pEvent->extParam;

	y = HIWORD(lParam) ;
	x = LOWORD(lParam) ;
	
	if (VIEW_PULL_START == extParam)
	{//是起始点

		if(GRAP_INWIDGET_RANGE(x,y,pButton))
	     {//在有效范围内
	         ret = VIEW_PULL_START;
	     }
	     else
	     {
	        return FAIL;
	     }
	}
	
	if (VIEW_PULL_START == extParam)
	{//down
		Grap_ChangeFocusEnable(pButton);

	    pButton->state = STATE_PRESS;
		pButton->draw(pButton, 0, 0);
	    DisplayData2Screen();
	}
	else if (VIEW_PULL_ING == extParam)
	{//拖拽中
	    if(GRAP_INWIDGET_RANGE(x,y,pButton))
	     {//在有效范围内
	         pButton->state = STATE_PRESS;
		     pButton->draw(pButton, 0, 0);
		     
		     ret = pButton->pressEnter(pView, pButton->state) ;
             if ( ret== RETURN_REDRAW)
             {
            	 ReDraw(pButton, 0, 0);
             }
             else if(ret == RETURN_QUIT)
             {
            	 *((tGRAPDESKBOX *)(pButton->pParent))->pQuitCnt = 1;
             }
             else if (ret == RETURN_FOCUSMSG)
             {
            	 return ret;
             }			
		     ret = VIEW_PULL_ING; 
	     }
	     else
	     {
	        pButton->state = STATE_NORMAL;
		    pButton->draw(pButton,0,0);
	     }

	    
	}
	else if (VIEW_PULL_END == extParam)
	{//up
	    pButton->state = STATE_NORMAL;
		pButton->draw(pButton,0,0);				
		DisplayData2Screen();

        if(!GRAP_INWIDGET_RANGE(x,y,pButton))
        {
            return VIEW_PULL_END;
        }    
        
		ret = pButton->pressEnter(pView, pButton->state) ;
		if ( ret== RETURN_REDRAW)
		{
			ReDraw(pButton, 0, 0);
			ret = VIEW_PULL_END;
		}
		else if(ret == RETURN_QUIT)
		{
			*((tGRAPDESKBOX *)(pButton->pParent))->pQuitCnt = 1;
		}
		else if (ret == RETURN_FOCUSMSG)
		{
			return ret;
		}			
		return PARSED;
	}
	else if (VIEW_PULL_TIMEOUT == extParam)
	{//超时
	    pButton->state = STATE_NORMAL;
		pButton->draw(pButton,0,0); 
		
		ret = VIEW_PULL_TIMEOUT;  
	}
	
	return ret;  
 
}

S32 LB_ButtonHandle(void *pView, GRAP_EVENT *pEvent)
{
	tGRAPBUTTON *pButton;
	U32 message, wParam, lParam ;
	int ret = SUCCESS;

	pButton = (tGRAPBUTTON *)pView;
	
	message = pEvent->message ;
	wParam = pEvent->wParam ;
	lParam = pEvent->lParam ;
	
	switch(message)
	{
	case VIEW_ENABLE:
		pButton->view_attr.enable = 1;
		pButton->draw(pButton, 0, 0);
		break;
	case VIEW_DISABLE:
		pButton->view_attr.enable = 0;
		break;
	case VIEW_DRAW:
	case VIEW_UPDATE:
		pButton->draw(pButton, 0, 0);
		break;
	case VIEW_PRESS:
		if ((U16)lParam == pButton->btn_privattr.keycode)
		{
			tGRAPVIEW *pTempView;
			
			pButton->view_attr.clNormal = pButton->view_attr.clFocus;
			pButton->btn_privattr.cl_normal = pButton->btn_privattr.cl_focus;
				
			pButton->state = STATE_PRESS;
			pButton->draw(pButton,0,0);
			DisplayData2Screen();
			syssleep(15);
			pButton->state = STATE_NORMAL;
			pButton->draw(pButton,0,0);
			DisplayData2Screen();
			ret = pButton->pressEnter(pView, pButton->state) ;
			if (ret== RETURN_REDRAW)
			{
				ReDraw(pButton, 0, 0);
				return PARSED;
			}
			else if(ret == RETURN_QUIT)
			{
				*((tGRAPDESKBOX *)(pButton->pParent))->pQuitCnt = 1;
			}
			else if (ret == RETURN_FOCUSMSG)
			{
				return ret;
			}	
		}
		break;
	case VIEW_CLICK:
	case VIEW_BTNUP:
		break ;	          
	case VIEW_QUIT:
		break;
	case VIEW_REV_SYSMSG:
		pButton->recvSysMsg(pView);
		break;
	case VIEW_REV_PULLMSG:
	    ret = pButton->recvPullMsg(pButton,pEvent);
	    break;	
	}
	return ret;
}


int LB_BtnPress(void *pView, U16 state)
{
	tGRAPDESKBOX	*pDesk;
	tGRAPBUTTON		*pBtn;

	if (state == STATE_NORMAL)
	{
		pBtn  = (tGRAPBUTTON *)pView;
		pDesk =  (tGRAPDESKBOX *)pBtn->pParent;
		switch(pBtn->view_attr.id)
		{
		case BUTTON_ID_1:
		/*	gu32LBQuitTime = rawtime(NULL);
			eLBState = LB_STATE_START;
			break;
		case BUTTON_ID_2:*/
		hyUsbPrintf("------------quit===========\r\n");
			return RETURN_QUIT;
			break;
		default:
			break;
		}
		
		return RETURN_REDRAW;
	}
	
	return RETURN_CANCLE;
}

/*-----------------------------------------------------
* 函数:LB_Desk
* 功能:拍照
* 参数:pWorkBuf:外部提供工作buf  最少2.2M
* 返回:0:成功
------------------------------------------------------*/
int LB_Desk(tGRAPDESKBOX *pFather, U8 *pWorkBuf)
{
	int				i,ret = 1;
	tGRAPDESKBOX	*pDesk	= NULL;
	tGRAPBUTTON		*pBtn;
	U16 			lastValue;
	U8				index=0;
	
	ConSume_UpdataSpeedDirect(SHELL_AN, 192);
	
	gpLBUseBuf = pWorkBuf;
	
	pDesk = Grap_CreateDeskbox(&LBViewAttr[index++], NULL);
	if (NULL == pDesk)
	{
		goto LB_BAD;
	}
	Grap_Inherit_Public(pFather, pDesk);
	pDesk->handle = LB_DeskboxHandle;
	
	Grap_ShowPicture(pDesk->view_attr.clNormal, 0, 0);
	drvLcd_SetColor(0xffff, 0);
	drvLcd_SetDisplayAddress(Get_Display_DisplayMemory_Offset());
	drvLcd_DisplayString(100,84,0,"请稍等...", NULL, 0);
	DisplayData2Screen();
	
	for (i=0; i<1; i++)
	{
		pBtn = Grap_InsertButton(pDesk,&LBViewAttr[index++],&LBBtnPrv[i]);
		if (NULL == pBtn)	goto LB_BAD;
		pBtn->pressEnter = LB_BtnPress;
		pBtn->recvPullMsg = LB_ButtonRecvPullMsg;
		pBtn->handle = LB_ButtonHandle;
	}

	if(0 != LB_Init())
	{
		Com_SpcDlgDeskbox("无摄像设备!",6,pDesk,2,NULL,NULL,100);
		Grap_DeskboxDestroy(pDesk);
		goto LB_BAD;
	}
	
	lastValue = BackLight_CloseScreenProtect();//记录屏保信息 退出时还原
	
	ComWidget_Link2Desk(pDesk,pgtComFirstChd);
	Grap_DeskboxRun(pDesk);
	ComWidget_LeftFromDesk(pDesk,pgtComFirstChd,COM_WIDGET_NUM);
	Grap_DeskboxDestroy(pDesk);

	BackLight_SetScreenProtect(lastValue);

	LB_DeInit();
	
	drvLcd_IsUseQueue(0);
	drvLcd_ClearQueue();
		
	ConSume_UpdataSpeedDirect(SHELL_AN, 0);
	
	return 0;
	
LB_BAD:
	
	LB_DeInit();
	drvLcd_IsUseQueue(0);
	drvLcd_ClearQueue();

	ConSume_UpdataSpeedDirect(SHELL_AN, 0);
	
	return -1;
}

